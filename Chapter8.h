#pragma once

// Свободные функции и макросы 
namespace nsFreeFunctionAndMacros
{
	void main();


	// Задача 8.1.Рекурсивные объявления(6)
	void task1();
	// Можете ли вы написать функцию, возвращающую указатель на саму себя?
	// Если да, то для чего она может вам пригодиться?
	// 1. Что такое указатель на функцию? Каким образом его можно использовать?

	// 2. Предположим, что можно написать функцию, которая возвращает указатель на саму себя.
	// Такая функция может одинаково хорошо возвращать указатель на любую функцию с той же сигнатурой, что и у нее самой.
	// Когда такая возможность может оказаться полезной?

	// 3. Можно ли написать функцию, которая возвращает указатель на саму себя?
	

	// Задача 8.2.Имитация вложенных функций(5)
	void task2();
	// В C++ есть вложенные классы, но нет вложенных функций.
	// В каких случаях вложенные функции могут оказаться полезными и как сымитировать их в C++?
	// 1. Что такое вложенный класс? Почему он может быть полезен?
	// 2. Что такое локальный класс? Почему он может быть полезен?
	// 3. C++ не поддерживает вложенные функции, так что мы не можем написать код наподобие следующего.

	// пример 1. вложенный класс 
	class OuterClass
	{
		/* public, protected или private: */
		class NestedClass
		{
			// ... 
		};
		// ... 
	};

	// Локальный класс — это класс, определенный в области видимости функции
	void f();
	// Локальный или неименованный классы нельзя использовать в качестве параметров шаблонов
	// Предпочитайте ясность. Избегайте сложных решений. Остерегайтесь запутанности.


	// Задача 8.3.Макросы препроцессора(4)
	void task3();
	// Макросы препроцессора представляют собой часть C++, унаследованную от С.
	// В данной задаче рассматриваются ситуации, когда макросы применимы в современном C++.
	// Избегайте использования макросов препроцессора, за исключением следующих ситуаций.
	// - Защита директивы #include
	// - Условная компиляция для обеспечения переносимости или отладки в .срр-файлах (но не в.h - файлах!).
	// - Использование директив #pragma для отключения предупреждений, о которых точно известно, что их можно игнорировать.
	// Такие директивы #pragma должны находиться только внутри директив условной компиляции, обеспечивающих переносимость, с тем, чтобы избежать возможных предупреждений компилятора о наличии неизвестной директивы.
	
	
	// Задача 8.4. #Definition(4) 
	void task4();
	// Что могут макросы и чего они не могут?
	// 1. Покажите, как написать простой макрос препроцессора max(), который принимает два аргумента и находит больший из них с использованием обычного оператора сравнения <.
	// Какие типичные ловушки встречаются при написании такого макроса?
	// 2. Чего не может создать макрос препроцессора и почему?
	// 1. Не забывайте о скобках вокруг аргументов
	// 2. Не забывайте о скобках вокруг всего выражения
	// 3. Многократное вычисление аргумента
	// 4. Конфликт имен

	// Прочие неприятности
	// 5. Макрос не может быть рекурсивным
	// 6. Макросы не имеют адресов
	// 7. Макросы трудно отлаживать
	// Таким образом в соответствующем стандарту компиляторе невозможно применение макроса для создания чего - либо из приведенного списка.
	// - Триграфы (замещаемые в первой фазе).
	// - Универсальные имена символов (\uxxxx, замещаемые в первой фазе).
	// - Символ продолжения строки (\ в конце строки, замещаемый во второй фазе).
	// - Комментарий (замещаемый в третьей фазе).
	// - Другой макрос или директива препроцессора (раскрываемые и выполняемые в четвертой фазе).
	// - Изменения в символе (например, ' х') или строке (например, "Hello") посредством наличия имен макросов внутри строки.
}
