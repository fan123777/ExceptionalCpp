#pragma once

// Пространства и поиск имен
namespace nsNamespaceAndNameSearch
{
	void main();

	// Задача 5.1.Поиск имен и принцип интерфейса.Часть 1(9.5)
	void task1();
	// Когда вы вызываете функцию — какую именно функцию вы вызываете?

	namespace A
	{
		struct X{};
		struct Y{};
		void f(int);
		void g(X);
	}

	namespace B
	{
		void f(int i);
		void g(A::X x);
		// Здесь возникает неоднозначность между выбором А::д(х) и в::д(х).  
		// Программист должен явно указать, какому именно пространству имен принадлежит вызываемая функция.
		// Поиск Кёнига(упрощенный) : если вы передаете функции аргумент типа класса(в нашем случае х типа А::х), то при поиске функции компилятором помимо прочих рассматриваются имена в пространстве имен(в нашем случае А), содержащем тип аргумента.
		void h(A::Y у);
	}

	// Задача 5.2.Поиск имен и принцип интерфейса.Часть 2(9)
	void task2();
	// Что содержится в классе, т.е. что является "частью"класса и его интерфейса?
	// Класс описывает множество данных вместе с функциями, оперирующими этими данными.
	// - Как ответ на этот вопрос согласуется с объектно-ориентированным программированием в стиле С?
	// - Как ответ на этот вопрос согласуется с поиском Кёнига? С примером Майерса?
	// - Как это влияет на анализ зависимостей классов и проектирование объектных моделей?
	// С учетом приведенного примера я предлагаю следующий принцип интерфейса (Interface Principle)
	// Для класса х все функции, включая свободные, которые - Упоминают х и - поставляются с X, являются логической частью X, поскольку они образуют часть интерфейса X.
	// Каждая функция-член по определению является частью X.
	
	// Поиск Кёнига


	// Задача 5.3.Поиск имен и принцип интерфейса.Часть 3(5)
	void task3();
	// Потратим несколько минут и рассмотрим влияние принципа интерфейса на проектирование программ.
	// Вернемся ненадолго к классическому вопросу проектирования: какой способ написания оператора << наилучший?
	// 1. В соответствии с принципом интерфейса, поскольку operator << упоминает X как в первом, так и во втором случае, и в обоих случаях поставляется с X, орerator << является логической частью х.
	// 2. В обоих случаях operator« упоминает ostream, так что operator« зависитот ostream.
	// 3. Поскольку в обоих случаях operator« является логической частью X и зависит от ostream, следовательно, X также в обоих случаях зависит от ostream.
	// В заключение мне бы хотелось предложить вам три вывода из серии задач Поиск имен и принцип интерфейса.
	// - Принцип интерфейса: для класса х все функции, включая свободные, которые "упоминают" X и "поставляются с" х, являются логической частью X, поскольку они образуют часть интерфейса х.
	// - Таким образом, логически частью класса могут быть как функции-члены, так и свободные функции. Однако функция - член связана с классом в большей степени, чем свободная функция.
	// - Трактовать в принципе интерфейса "поставляется с" можно как "находится в том же заголовочном файле и/или пространстве имен".
	// Если функция находится в том же заголовочном файле, что и класс, с точки зрения зависимостей она является частью класса.
	// Если же функция находится с классом в одном пространстве имен, то она является частью класса в смысле использования объекта и поиска имен.


	// Задача 5.4. Поиск имен и принцип интерфейса. Часть 4(9)
	void task4();
	// 1. Что такое сокрытие имен?
	// Покажите, каким образом оно может влиять на видимость имен базовых классов в производных классах.
	// 2. Будет ли корректно скомпилирован приведенный далее фрагмент кода?

	// Вкратце, при объявлении функции с именем g в производном классе D, автоматически скрываются все функции с тем же именем во всех непосредственных и опосредованных базовых классах.
	// using B::g;
	// Разумно используйте пространства имен.
	// Если вы помещаете класс в пространство имен, убедитесь, что вы разместили в том же пространстве все вспомогательные функции и операторы.
	// Если не сделать этого, в своем коде вы можете обнаружить самые неожиданные и нежелательные сюрпризы.
}
