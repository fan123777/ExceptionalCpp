#pragma once

#include <cassert>
#include <string>
#include <iostream>
#include <memory>

using namespace std;

// Вопросы и технологии безопасности исключений
namespace nsExceptionSafety
{
	void main();


	// Задача 2.1. Разработка безопасного кода. Часть 1(7)
	void task1();
	// - Какие "уровни" безопасности исключений имеются?
	// - Обязаны ли обобщенные контейнеры быть полностью нейтральными поотношению к исключениям?
	// - Являются ли контейнеры стандартной библиотеки безопасными и нейтральными?
	// - Влияет ли требование безопасности на дизайн открытого интерфейса ваших контейнеров?
	// - Должны ли обобщенные контейнеры использовать спецификации исключений?

	// Конструктор по умолчанию 
	template<class T> class Stack
	{
	public:
		Stack()
			:v_(0),
			vsize_(10),
			vused_(0)
		{
			v_ = new T[vsize_];
		}

		~Stack();

		Stack(const Stack&);
		Stack& operator=(const Stack&);

		size_t Count() const;
		void Push(const T&);
		void Pop(); // Если стек пуст, генерируется исключение 
		T& Top();

	private:
		T* v_;
		size_t vsize_;
		size_t vused_;
	};

	// Если функция не обрабатывает (не преобразует или преднамеренно не перехватывает) исключение, она должна разрешить его передану вызывающей функции, где исключение и будет обработано.
	// Всегда структурируйте ваш код таким образом, чтобы при наличии исключений ресурсы корректно освобождались, а данные находились в согласованном состоянии.

	// Деструктор 
	template<class T>
	Stack<T>::~Stack()
	{
		delete[] v_; // тут исключения генерироваться не могут 
	}
	// Никогда не позволяйте исключениям выйти за пределы деструктора или переопределенных операторов delete() или delete[]().
	// Разрабатывайте каждую из этих функций так, как если бы они имели спецификацию исключений throw().

	// Задача 2.2.Разработка безопасного кода.Часть 2(8)
	void task2();
	// Теперь, когда у нас есть конструктор по умолчанию и деструктор, мы можем решить, что написать другие функции так же просто.
	// Разработайте безопасные и нейтральные конструктор копирования и оператор присваивания и решите, так ли это просто, как кажется на первый взгляд.

	template<class T>
	T* NewCopy(const T* src, size_t sresize, size_t destsize)
	{
		assert(destsize >= sresize);
		T* dest = new T[destsize];
		try
		{
			copy(src, src + sresize, dest);
			catch (...)
			{
				deleted dest; // Здесь исключений не может быть 
				throw; // Передаем исходное исключение 
			}
			return dest;
		}
	}

	// Конструктор копирования 
	template<class T>
	Stack<T>::Stack(const Stack<T>& other)
		: v_(NewCopy(other.v_,
		other.vsize_,
		other.v_size_)),
		vsize__(other.vsize_),
		vused__(other.vusecL)
	{
	}

	// Копирующее присваивание 
	template<class T>
	Stack<T>& Stack<T>::operator=(const Stack<T>& other)
	{
		if (this != &other)
		{
			T* v_new = NewCopy(other.v_,
				other.vsize_,
				other.vsize_);
			delete[] v_; // Здесь исключений не может быть 
			v_ = v_new; // вступаем во владение 
			vsize_ = other.vsize_;
			vused_ = other.vused_;
		}
		return *this; // Безопасно, копирование не выполняется 
	}

	// В каждой функции следует собрать весь код, который может генерировать исключения, и  выполнить его отдельно, безопасным с точки зрения исключений способом.
	// Только после этого, когда вы будете знать, что вся реальная работа успешно выполнена, вы можете изменять состояние программы(а также выполнять другие необходимые действия, например, освобождение ресурсов) посредством операций, которые не генерируют исключений.


	// Задача 2.3. Разработка безопасного кода. Часть 3(9.5)
	void task3();

	// Count() 
	template<class T>
	size_t Stack<T>::Count() const
	{
		return vused_; // Безопасно; исключения не генерируются 
	}

	// Push() 
	template<class T>
	void Stack<T>::Push(const T& t)
	{
		if (vused_ == vsize_)
		{
			// При необходимости увеличиваем 
			// размер выделенной памяти 
			size_t vsize_new = vsize_ * 2 + 1;
			T* v_new = NewCopy(v_, vsize_, vsize_new);
			delete[] v_;
			v_ = v_new;
			vsize_ = vsize_new;
		}
		v_[vused_] = t;
		++vused_;
	}
	// В каждой функции следует собрать весь код, который может генерировать исключения, и  выполнить его отдельно, безопасным с точки зрения исключений способом.
	// Только после этого, когда вы будете знать, что вся реальная работа успешно выполнена, вы можете изменять состояние программы(а также выполнять другие необходимые действия, например, освобождение ресурсов) посредством операций, которые не генерируют исключений.

	// Рор()
	// насколько на самом деле безопасен этот код? 
	template<class T>
	void Stack<T>::Pop()
	{
		if (vused_ == 0)
			throw "pop from empty stack";
		else
		{
			
			--vused_;
			
		}
	}

	// Вывод — и он очень важен! — следующий: безопасность исключений влияет на разработку класса.
	// Другими словами, вы должны изначально думать о безопасности, которая никогда не является "просто деталью реализации".
	// Никогда не откладывайте продумывание вопросов безопасности исключении.
	// Безопасность влияет на конструкцию класса и не может быть "просто деталью реализации".
	// Прилагайте максимум усилий к тому, чтобы каждая часть кода — каждый модуль, класс, функция, — отвечали за выполнение одной четко определенной задачи.
	template<class T>
	T& Stack<T>::Top()
	{
		if (vused_ == 0)
			throw "pop from empty stack";
		else
			return v_[vused_ - 1];
	}
	// "Небезопасный по отношению к исключениям " и "плохой дизайн " идут рука об руку.
	// Если часть кода не безопасна, обычно это не означает ничего страшного и легко исправляется.
	// Но если часть кода не может быть сделана безопасной из - за лежащего в ее основе дизайна, то практически всегда это говорит о плохом качестве дизайна.
	// Пример 1: трудно сделать безопасной функцию, отвечающую за выполнение двух различных задач.
	// Пример 2 : оператор копирующего присваивания, написанный так, что он должен проверять присваивание самому себе, вероятнее всего, не является строго безопасным.


	// Задача 2.4. Разработка безопасного кода. Часть 4(8)
	void task4();
	
	// 1. Базовая гарантия: даже при наличии генерируемых Т или иных исключений утечки ресурсов в объекте Stack отсутствуют.
	// 2. Строгая гарантия: если операция прекращается из-за генерации исключения, состояние  программы остается неизменным.
	// 3. Гарантия отсутствия исключений: функция не генерирует исключений ни при каких обстоятельствах.
	// Не забывайте о базовой, строгой гарантиях и гарантии отсутствия исключений при разработке безопасного кода.
	// Разработанный нами шаблон Stack требует от инстанцирующего типа соблюдения следующих условий:
	// - Наличия конструктора по умолчанию (для создания буфера v_).
	// - Наличия копирующего конструктора (если Pop() возвращает значение). 
	// - Деструктор, не генерирующий исключений (чтобы иметь возможность гарантировать безопасность кода).
	// - Безопасное присваивание (для установки значений в буфере v_; если копирующее присваивание генерирует исключение, оно должно гарантировать, что целевой объект остается корректным объектом типа T.
	// Заметим, что это единственная функция - член T, которая должна быть безопасна для того, чтобы класс Stack был безопасен).


	// Задача 2.5. Разработка безопасного кода. Часть 5(7)
	void task5();

	// - Каким образом можно использовать более продвинутые технологии для упрощения управления ресурсами(и кроме того, для устранения использованного блока try / catch)?
	// - Каким образом можно усовершенствовать класс Stack, снизив требования к классу т элементов стека?
	// - Должны ли обобщенные контейнеры использовать спецификации исключений?
	// - Что в действительности делают операторы new[] и deleted?

	template<class T>
	class StackImpl
	{
	public:
		StackImpl(size_t size)
			: v_(static_cast<T*>(size == 0 ? 0 : operator new (sizeof(T)* size))),
			vsize_(size),
			vused(0)
		{
		}

		~StackImpl()
		{
			// Здесь исключений не может быть 
			destroy(v_, v_ + vused_);
			operator delete(v_);
		}

		void Swap(StackImpl& other) throw()
		{
			swap(v_, other.v_);
			swap(vsize_, other.vsize_);
			swap(vused_, other.vused_);
		}

		T* v_; //Указатель на область памяти, достаточную
		size_t vsize_; //для размещения vsize_ объектов типа T
		size_t vused_; //количество реально используемых объектов

	private:
		// Закрыты и не определены: копирование запрещено
		StackImpl(const StackImpl&);
		StackImpl& operator=(const StackImpl&);

		// construct() создает новый объект в указанном месте 
		// с использованием определенного начального значения
		template<class T1, class T2>
		void construct(T1* p, const T2& value)
		{
			new(p)T1(value);
		}

		// destroy() уничтожает объект или
		// диапазон объектов
		template<class T>
		void destroy(T* p)
		{
			p->~ТС();
		}

		template <class FwdIter>
		void destroy(FwdIter first, FwdIter last)
		{
			while (first != last)
			{
				destroy(&*first);
				++first;
			}
		}
		// swap() просто обменивает два значения 
		// 
		template<class T>
		void swap(T& а, T& b)
		{
			T temp(a);
			а = b;
			b = temp;
		}
	};

	// Прилагайте максимум усилий к тому, чтобы каждая часть кода - каждый модуль, класс, функция, — отвечали за выполнение одной четко определенной задачи.


	// Задача 2.6.Разработка безопасного кода.Часть 6(9)
	void task6();

	template<class T>
	class Stack1 : private StackImpl<T>
	{
	public:
		Stack1(size_t size = 0)
			:StackImpl<T>(size)
		{
		}

		Stack1(const Stack& other)
			:StackImpl<T>(other.vused_)
		{
			while (vused_ < other.vused_)
			{
				construct(v_ + vused_, other.v_[vused_]);
				++vused_;
			}
		}

		Stack1& operator = (const Stack1& other)
		{
			Stack1 temp(other);
			Swap(temp);
			return *this;
		}

		size_t Count() const
		{
			return vused_;
		}

		void Push(const T&)
		{
			if (vused_ == vsize_)
			{
				Stack temp(vsize_ * 2 + 1);
				whi!e(temp.Count() < vused_)
				{
					temp.Push(v_[temp.Count()]);
				}
				temp.Push(t);
				Swap(temp);
			}
			else
			{
				construct(v_ + vused_, t);
				++vused_;
			}
		}

		T& Top() // Если стек пуст, генерируется исключение 
		{
			if (vused_ == 0)
				throw "empty stack";
			return v_[vused_ - 1];
		}

		void Pop() // Если стек пуст, генерируется исключение 
		{
			if (vused_ == 0)
			{
				throw "pop from empty stack";
			}
			else
			{
				--vused_;
				destroy(v_ + vused_);
			}
		}
	};

	// Всегда используйте идиому "захвата ресурса при инициализации " для отделения владения и управления ресурсами.
	// В каждой функции следует собрать весь код, который может генерировать исключения, и выполнить его отдельно, безопасным с точки зрения исключений способом.
	// Только после этого, когда вы будете знать, что вся реальная работа успешно выполнена, вы можете изменять состояние программы(а также выполнять другие необходимые действия, например, освобождение ресурсов) посредством операций, которые не генерируют исключений.
	
	
	// Задача 2.7.Разработка безопасного кода.Часть 7(5)
	void task7();

	template<class T>
	class Stack2
	{
	public:
		Stack2(size_t size = 0)
			:impl_(size)
		{
		}

		Stack2(const Stack2& other)
			:impl_(other.impl_.vused_)
		{
			while (impl_.vused_ < other.impl_.vused_)
			{
				construct(impl_.v_ + impl_.vused_,
					other.impl_.v_[impl_.vused_]);
				++impl_.vused_;
			}
		}

		Stack2& operator=(const Stack2&)
		{
			Stack2 temp(other);
			impl_.Swap(temp.impl_); // Здесь исключений нет 
			return *this;
		}

		size_t Count() const
		{
			return impl_.vused_;
		}

		void Push(const T& t)
		{
			if (impl_.vused_ == impl_.vsize_)
			{
				Stack2 temp(impl_.vsize_ * 2 + 1);
				whi1e(temp.Count() < impl_.vused_)
				{
					temp.Push(impl_.v_[temp.Count()]);
				}
				temp.Push(t);
				impl_.Swap(temp.impl_);
			}
			else
			{
				construct(impl_.v_ + impl_.vused_, t);
				++impl_.vused_;
			}
		}

		T& Top() // Если стек пуст, генерируется исключение
		{
			if (impl_.vused_ == 0)
			{
				throw "empty stack";
			}
			return impl_.v_[impl_.vused_ - 1];

		}

		void Pop() // Если стек пуст, генерируется исключение
		{
			if (impl_.vused_ == -0)
			{
				throw "pop from empty stack";
			}
			else
			{
				--impl_.vused_;
				destroy(impl_.v_ + impl_.vused_);
			}
		}

	private:
		StackImpl<T> impl_; // Сокрытие реализации 
	};


	// Задача 2.8. Разработка безопасного кода. Часть 8(9)
	void task8();
	// 1. Какая технология лучше — использовать Stacklmpl в качестве закрытого базового класса или в качестве объекта - члена?
	// Используйте наследование только тогда, когда это абсолютно необходимо, что означает следующее:
	// - вам необходим доступ к защищенным членам класса, или
	// - вам требуется переопределение виртуальной функции, или
	// - объект должен быть сконструирован раньше других базовых подобъектов.
	// 2. Насколько повторно используемы последние версии stack?
	// Какие требования предъявляются к типу элементов стека T? (Другими словами, с объектами каких типов может работать Stack ? Чем меньше требований к типу T, тем больше степень повторного использования Stack.)
	// требования новой версии Stack снижены до наличия:
	// - конструктора копирования и
	// - деструктора, не генерирующего исключений (для обеспечения безопасности).
	// При разработке всегда помните о повторном использовании.
	// 3. Следует ли использовать спецификации исключений для функций-членов Stack? 
	// - Указание ограничения throw() ограничит в будущем ваши возможности по изменению реализации этих функций — вы не будете иметь права генерировать в них исключения.
	// Ослабление же спецификации исключений всегда несет определенный риск нанесения вреда существующему клиенту (новая версия класса нарушает старое обещание), так что ваш класс будет плохо поддаваться внесению изменений.
	// (Указание спецификации исключений у виртуальных функций, кроме того, снижает повторное использование класса, поскольку существенно ограничивает возможности программистов, которые могут захотеть использовать ваш класс в качестве базового для создания своих собственных классов, производных от вашего.
	// Использование спецификации может иметь смысл, но такое решение требует длительных размышлений.)
	// - Спецификации исключений могут привести к повышенным накладным расходам независимо от того, генерируется ли на самом деле исключение или нет(хотя многие современные компиляторы и минимизируют эти расходы).
	// Для часто используемых операций и контейнеров общего назначения лучше все же избегать дополнительных расходов и не использовать спецификации исключений.


	// Разработка безопасного кода. Часть 9(8)
	void task9();
	// 1. Что в действительности делает delete[] p;?
	// 2. Насколько безопасно данное выражение? Будьте максимально точны в своем ответе.
	// Никогда не позволяйте исключениям покинуть деструктор или переопределенные операторы delete() и delete[]().
	// Разрабатывайте каждый деструктор и функции удаления объектов так, как если бы они имели спецификацию исключений throw().
	// Не забывайте о канонических правилах безопасности исключений.
	// 1. Никогда не позволяйте исключениям покинуть деструктор или переопределенные операторы delete() и delete[]()
	// Разрабатывайте каждый деструктор и функции удаления объектов так, как если бы они имели спецификацию исключений throw().
	// 2. Всегда используйте идиому "захвата ресурса при инициализации " для отделения владения и управления ресурсами.
	// 3. В каждой функции следует собрать весь код, который может генерировать исключения, и выполнить его отдельно, безопасным с точки зрения исключений способом.
	// Только после этого, когда вы будете знать, что вся реальная работа успешно выполнена, вы можете изменять состояние программы(а также выполнять другие необходимые действия, например, освобождение ресурсов) посредством операций, которые не генерируют исключений.
	
	
	// Задача 2.10. Разработка безопасного кода. Часть 10(9.5)
	void task10();
	// Безопасность исключений и стандартная библиотека
	// - Все итераторы, возвращаемые стандартными контейнерами, безопасны и могут копироваться без генерации исключений.
	// - Все стандартные контейнеры должны реализовывать базовую гарантию для всех операций: они всегда разрушаемы и всегда находятся в согласованном(если не предсказуемом) состоянии даже при наличии исключений.
	// - Для того чтобы это стало возможным, ряд важных функций должен реализовывать гарантию отсутствия исключений, включая swap(важность которой была продемонстрирована в предыдущей задаче), all ocator<T>::deallocate (важность этой функции продемонстрирована в процессе рассмотрения оператора delete()) и некоторых операций типов - параметров шаблонов(в особенности деструктора, о чем говорилось в задаче 2.9, в разделе "Деструкторы, генерирующие исключения, и почему они неприемлемы").
	// - Все стандартные контейнеры должны также реализовывать строгую гарантию для всех операций(с двумя исключениями).
	// Они должны всегда следовать семантике принятия - или - отката, так что операции типа вставки должны быть либо полностью успешны, либо не изменять состояние программы вовсе.
	// "Не изменять состояние" означает, что неуспешно завершившаяся операция не влияет на корректность любого итератора, который в начале операции указывает внутрь контейнера.


	// Задача 2.11.Сложность кода.Часть 1(9)
	void task11();

	class Employee
	{
	public:
		string Title()
		{
			return "";
		}

		int Salary()
		{
			return 0;
		}

		string First()
		{
			return "";
		}

		string Last()
		{
			return "";
		}
	};
	// Сколько путей выполнения может быть в приведенном коде?
	string EvaluateSalaryAndReturnName(Employee e);
	// 1. Игнорируем различный порядок вычисления параметров функции, как и возможные сбои в работе деструкторов.
	// Сразу же вопрос для героев : насколько изменится количество путей выполнения, если деструкторы могут генерировать исключения?
	// 2. Рассматриваем вызываемые функции как атомарные. Например, вызов е.Title() может генерировать исключения по самым разным причинам(генерация исключения может быть вызвана кодом самой функции;
	// функция может не перехватывать исключение, сгенерированное другой функцией; исключение может генерироваться конструктором временного объекта и т.д.).
	// Все, что нас интересует при рассмотрении данной функции, — сгенерировано ли исключение при ее работе или нет.
	// 3. При подсчете различных путей выполнения учитываем, что каждый из них должен состоять из своей уникальной последовательности вызовов и выходов из функций.
	// Всегда помните об исключениях. Вы должны точно знать, где именно они могут генерироваться.
	
	
	// Задача 2.12. Сложность кода. Часть 2(7)
	void task12();
	// Сделайте три строки кода из предыдущей задачи безопасными с точки зрения исключений.
	// Эта задача преподнесет важный урок, касающийся безопасности.
	string SafeEvaluateSalaryAndReturnName(Employee e);
	// Вкратце: базовая гарантия обеспечивает уничтожение объектов и отсутствие утечек; строгая, кроме того, обеспечивает семантику принятия - или - отката.
	// Гарантия отсутствия исключений гарантирует, что функция не генерирует исключений.
	// функцияSafeEvaluateSalaryAndReturnName имеет два побочных действия:
	// - В поток cout выводится сообщение "...overpaid...".
	// - Возвращается строка с именем.
	// функция небезопасна по двум причинам:
	// - Если исключение генерируется после того, как в cout выведена первая часть сообщения, но до завершения всего вывода(например, если исключение генерируется четвертым оператором <<), то в cout будет выведена только часть сообщения.
	// - Если же сообщение выведено полностью, но после этого в функции генерируется исключение(например, во время построения возвращаемого значения), то сообщение оказывается выведенным, несмотря на то, что выполнение функции завершается неуспешно.
	// Четко различайте требования различных гарантий безопасности.
	// unique_ptr<>
	// Прилагайте максимум усилий к тому, чтобы каждая часть кода - каждый модуль, класс, функция, — отвечали за выполнение одной четко определенной задачи.
	// Эта задача проиллюстрировала три важных момента.
	// 1. Обеспечение строгой гарантии часто (но не всегда) требует от вас идти на компромисс со снижением производительности.
	// 2. Если функция имеет множественные несвязанные побочные действия, она не всегда может быть сделана строго безопасной.
	// Если сделать ее строго безопасной невозможно, ее следует разбить на ряд функций, в каждой из которых побочные действия могут быть выполнены атомарно.
	// 3. Не все функции обязаны быть строго безопасными.
	// Как исходный код, так и код из первой попытки удовлетворяют условиям базовой гарантии.
	// Для множества клиентов попытки №1(минимизирующей возможности побочных действий при наличии исключений без снижения производительности) будет вполне достаточно.
	

	// Задача 2.13. Исключения в конструкторах. Часть 1(4)
	void task13();
	// Что именно происходит при генерации исключения конструктором?
	// Что происходит, когда исключение генерируется при попытке создания подобьекта или объекта - члена?
	// 1. Рассмотрим следующий класс.
	class A
	{

	};

	class B
	{

	};

	// пример 1 
	// 
	class C: private A
	{
		C();

		B b_;
	};
	// Как в конструкторе С можно перехватить исключение, сгенерированное в конструкторе базового подобьекта(такого, как А) или объекта - члена(такого, как Ь_)?
	// 2. Рассмотрим следующий код.
	// Пример 2 
	// {
	//		Parrot p;
	// }
	// Когда начинается время жизни объекта? Когда оно заканчивается? Каково состояние объекта за рамками его времени жизни?
	// И наконец, что будет означать генерация исключения в конструкторе объекта?
	// - что означает конструирование объектов и сбой конструктора в C++;
	// - как использовать try-блоки функций для преобразования (не подавления) исключений, сгенерированных конструкторами базового подобъекта или объекта - члена.
	// Try-блоки функций 
	// Время жизни объекта и исключения в конструкторе
	// Когда начинается время жизни объекта?
	// - Когда его конструктор успешно завершает свою работу и осуществляется обычный выход из него(т.е.когда управление достигает конца тела конструктора или завершается до этого посредством инструкции return).
	// Когда завершается время жизни объекта?
	// - Когда начинается выполнение деструктора (т.е. когда управление достигает начала тела деструктора).
	// Каково состояние объекта по окончании его времени жизни?
	// Заметим в скобках: все гуру в области программирования злоупотребляют антропоморфизмами, говоря о коде, объектах и других сущностях как об одушевленных существах.
	// Что означает генерация исключения конструктором?
	// - Это означает, что при работе конструктора происходит сбой, что объект никогда не существовал и что его время жизни никогда не начиналось.
	// Единственный способ сообщить о сбое при работе конструктора — т.е. о невозможности корректно создать объект данного типа — состоит в генерации исключения.
	// (Ранее использовавшееся соглашение, гласящее "при возникновении неприятностей установите соответствующий флаг статуса и позвольте вызывающей функции проверить его посредством функции isOK()", более недействительно.) 
	// 1. Либо выход из конструктора происходит естественным путем (по достижении его конца, либо посредством инструкции return), и объект начинает свое существование.
	// 2. Либо выход из конструктора осуществляется посредством генерации исключения, и соответствующий объект не только не существует, но и никогда не существовал в качестве объекта.


	// Задача 2.14. Исключения в конструкторах. Часть 2(7)
	void task14();
	// 1. Если в примере 1 из задачи 2.13 конструктор А или В генерирует исключение, может ли конструктор С поглотить его и в результате не выпустить никаких исключений вообще? Обоснуйте ваш ответ, подтвердив его примерами.
	// 2. Каким минимальным требованиям должны удовлетворять А и в для того, чтобы мы могли безопасно указать пустую спецификацию исключений конструктора С?
	// Нельзя задерживать не перехваченные исключения
	// Каким образом может осуществляться выход из обработчика try - блока конструктора?
	// - Обработчик исключения не может использовать инструкцию return; — это запрещено правилами языка.
	// - Если обработчик воспользуется инструкцией throw;, то это будет означать, что он просто передает вызывающей функции исключения, изначально сгенерированные в конструкторах А::A() и В::B().
	// - Если обработчик генерирует некоторое другое исключение, то это исключение заменит сгенерированное конструктором базового подобъекта или подобъекта - члена.
	// - Если выход из обработчика не осуществляется путем генерации исключения (либо нового, либо передачи исходного исключения вызывающей функции посредством инструкции throw;) и управление достигает конца catch - блока в конструкторе или деструкторе, то исходное исключение автоматически передается вызывающей функции, как если бы была использована инструкция throw;.
	// Это не очевидно, но явно указано в стандарте C++.
	// в C++ при генерации исключения конструктором любого базового подобъекта или подобъекта - члена конструктор всего объекта также должен сгенерировать исключение.
	// Кстати, рассмотренный материал означает, что единственное (повторяю - единственное) возможное применение try - блока конструктора состоит в том, чтобы транслировать исключение, сгенерированное конструктором базового подобъекта или подобъекта - члена.
	// Отступление: почему C++ поступает таким образом?
	// используйте умные указатели.
	// "Обращение к любому нестатическому члену или базовому классу объекта в обработчике try - блока конструктора данного объекта приводит к неопределенному поведению".
	// Мораль о try-блоках функций
	// Мораль #1. Обработчик try-блока конструктора пригоден только для трансляции исключения, сгенерированного в конструкторе базового подобъекта или подобъекта- члена.
	// Мораль #2. Try-блоки деструкторов практического применения не имеют, поскольку деструкторы не должны генерировать исключения.
	// Мораль #3. Все остальные try-блоки функций практического применения не имеют.
	// Мораль о безопасном кодировании
	// Мораль #4. Неуправляемое выделение ресурсов всегда выполняйте в теле конструктора и никогда — в списках инициализации.
	// Мораль #5. Ресурсы, выделенные неуправляемым способом, следует освобождать в обработчике локального try - блока в теле конструктора или деструктора, но никогда - в обработчике try - блока конструктора или деструктора.
	// Мораль #6. Если конструктор имеет спецификацию исключений, то она должна объединять все возможные исключения, которые могут быть сгенерированы базовыми подобъектами и подобъектами - членами.
	// Мораль #7. Используйте для хранения "необязательных частей" внутреннего представления класса идиому указателя на реализацию.
	// Мораль №8. Для управления ресурсами используйте принцип "выделение ресурса есть инициализация".
	

	// Задача 2.15.Неперехваченные исключения(6)
	void task15();
	// Что собой представляет стандартная функция uncaught_exception() и когда она должна использоваться?
	// Ответ на этот вопрос для многих обычно оказывается неожиданным.
	// 1. Что делает функция uncaught_exception()?
	// 2. Рассмотрим следующий код.
	// T::~T()
	// {
	//	if (!std::uncaught_exception())
	//	{
	//		// код, который может генерировать исключения 
	//	}
	//	else
	//	{
	//		// код, не генерирующий исключения 
	//	}
	// }
	// Насколько корректна данная методика? Приведите аргументы "за" и "против".
	// 3. Имеется ли еще какое-нибудь корректное применение функции uncaught_exception()? Рассмотрите этот вопрос и изложите свои выводы.
	// Если деструктор генерирует исключение в то время, когда активно другое исключение(т.е.в процессе свертки стека), программа прекращает работу.
	// Обычно это не самый лучший выход.
	// Корректное решение:
	//T::Close()
	//{
	//	// код, который может генерировать исключения 
	//	T::~T() /* throw() */
	//	{
	//		try
	//			closeO;
	//	}
	//	catch (...){}
	//}
	// Никогда не позволяйте исключениям покинуть деструктор или переопределенные операторы delete() и delete[]().
	// Разрабатывайте каждый деструктор и функции удаления объектов так, как если бы они имели спецификацию исключений throw() (использовать ли эту спецификацию в коде или нет — дело вашего вкуса).
	// Если деструктор вызывает функции, которые могут генерировать исключения, всегда осуществляйте эти вызовы в блоках try / catch для предотвращения выхода исключения за пределы деструктора.


	// Задача 2.16. Проблема неуправляемых указателей. Часть 1(6)
	void task16();
	// 1. Что вы можете сказать о порядке вычислений функций f, g и h и выражений expr1 и ехрг2 в каждом из приведенных фрагментов? Полагаем, что выражения expr1 и ехрг2 вызовов функций не содержат.
	// пример 1а 
	// 
	// f(expr1, ехрг2);
	// пример 1б
	// 
	// f(g(expr1), h(expr2));
	// 2. Роясь в архивах, вы нашли такой фрагмент кода.
	// пример 2 
	// 
	// в заголовочном файле: 
	// void f(T1*, T2*);
	// в файле реализации 
	// f(new T1, new T2);

	// Порядок и беспорядок вычислений
	// 1. До того как будет вызвана функция, все ее аргументы должны быть полностью вычислены.
	// Сюда включается завершение выполнения всех побочных действий выражений, используемых в качестве аргументов функций.
	// 2. После того как началось выполнение функции, никакие выражения извызывающей функции не начинают и не продолжают вычисляться до тех пор, пока не будет полностью завершена вызванная функция.
	// Выполнения функций никогда не чередуются друг с другом.
	// 3. Выражения, используемые в качестве аргументов функций, вообще говоря,могут вычисляться в любом порядке, включая чередование, если только это не запрещено какими - либо другими правилами.
	// 1б:
	// - expr1 должно быть вычислено до вызова g().
	// - ехрг2 должно быть вычислено до вызова h().
	// - И g(), и h() должны быть вычислены до вызова f().
	// - Вычисление выражений expr1 и ехрг2 может чередоваться друг с другом, но не с вызовом любой функции.
	// Например, между началом выполнения g() и ее завершением не могут осуществиться ни никакая часть вычисления выражения ехрг2, ни вызов h().
	
	// Вызов функций и безопасность


	// Задача 2.17. Проблема неуправляемых указателей. Часть 2(8)
	void task17();
	// Решает ли проблему из задачи 2.16 применение auto_ptr?
	// 1. Продолжая рыться в архивах, вы находите фрагмент кода, очень похожий на найденный в задаче 2.16, но с определенными изменениями.
	// Пример 1 
	// В заголовочном файле: 
	// void f(auto_ptr<T1>, auto_ptr<T2>);
	// в файле реализации 
	// f(auto_ptr<T1>(new T1), auto_ptr<T2>(new T2));
	// В чем состоит данное улучшение кода из задачи 2.16, если таковое имеется? 
	// Остаются ли в данном варианте кода проблемы с безопасностью исключений? Поясните свой ответ.
	// 2. Покажите, каким образом следует написать вспомогательное средство auto_ptr_new, которое решит проблемы безопасности из первой части задачи и которое можно использовать следующим образом.
	// Пример 2 
	// 
	// в заголовочном файле: 
	// void f(auto_ptr<T1>, auto_ptr<T2>);
	// в файле реализации 
	// f(auto_ptr_new<T1>(), auto_ptr_new<T2>());
	/*template<typename T>
	auto_ptг<T> auto_ptr_new()
	{
		return auto_ptг<T>(new T);
	}*/
	// Никогда не выделяйте ресурсы (например, посредством new) в том же выражении, где другой код может генерировать исключение.
	// Это правило должно использоваться даже в том случае, если выделенный посредством new ресурс станет управляемым(например, будет передан конструктору auto^ptr) в том же выражении.
	// Выполняйте каждое явное выделение ресурса (например, посредством new) в отдельной инструкции, в которой тут же выполняется его передача управляющему объекту (например, auto_ptг).
	// Выполняйте каждое явное выделение ресурсов (например, посредством new) в своей собственной инструкции кода, которая немедленно передает выделенный ресурс управляющему объекту(например, auto_.ptг).
	
	
	// Задача 2.18. Разработка безопасных классов. Часть 1(7)
	void task18();
	// Mожно ли сделать любой класс C++ строго безопасным, например, сделать строго безопасным оператор копирующего присваивания? Если да, то как? Какие при этом возникают вопросы и какие из этого следуют выводы? В этой задаче в качестве иллюстративного материала используется пример Каргилла widget.
	// 1. Перечислите три общие уровня безопасности исключений.
	// Кратко опишите каждый из них и поясните его важность.
	// 2. Как выглядит каноническая форма строго безопасного копирующего присваивания?
	// 3. Рассмотрим следующий класс
	// пример 1. пример widget каргилла
	class widget
	{
	public:
		widget& operator=(const widget&);
		// ... 
	private:
		int t1_;
		string t2_;
	};
	// Предположим, что любые операции T1 и Т2 могут генерировать исключения.
	// Можно ли, не изменяя структуру класса, написать строго безопасный оператор widget::operator(const widget&)?
	// Если да, то как? Если нет, то почему? Какие из этого можно сделать выводы?
	// 4. Опишите и продемонстрируйте простое преобразование, работающее с любым классом и делающее копирующее присваивание этого класса(почти) строго безопасным.
	// Где мы встречались с этой технологией(в другом контексте) ранее?
	// - Можно ли сделать любой произвольный класс безопасным, не изменяя его структуру?
	// - Если нет (т.е. если безопасность влияет на конструкцию класса), то существует ли простое изменение, которое всегда позволяет нам сделать произвольный класс безопасным?
	// - Влияет ли способ выражения взаимоотношений между классами на безопасность?
	// Конкретно — имеет ли значение, выражаем ли мы это взаимоотношение с использованием наследования или с использованием делегирования?

	// Каноническая форма безопасности
	// - Базовая гарантия: при наличии исключений утечки ресурсов отсутствуют, а объект остается используемым и уничтожаемым и находится в согласованном, однако не обязательно предсказуемом состоянии.
	// Это наиболее слабый уровень безопасности исключений, он применим тогда, когда вызывающий код в состоянии справиться со сбойными операциями, которые вносят изменения в состояние объекта.
	// - Строгая гарантия: при наличии исключений состояние программы остается неизменным.
	// Этот уровень приводит к семантике принятия - или - отката(commit - or - rollback), что включает, в частности, действительность всех ссылок и итераторов, указывающих на элементы контейнера.
	// - Гарантия отсутствия исключений: функция не генерирует исключений ни при каких обстоятельствах.
	// Оказывается, иногда невозможно реализовать строгую или даже базовую гарантию до тех пор, пока не будет достигнута гарантия того, что определенные функции не будут генерировать исключений(например, деструкторы или функции освобождения памяти).
	// Как мы увидим ниже, очень важным свойством стандартного класса auto_ptr является то, что его операции не генерируют исключений.

	// Каноническая форма копирующего присваивания включает два шага.
	// 1.
	// void T::Swap(T& other) /* throw() */
	// {
	//	Обменивает внутренние состояния *this и other 
	// }
	// 2.
	// T& T::operator=(const T& other)
	// {
	// 	T temp(other); // выполняется вся необходимая работа 
	// 	Swap( temp ); //и принятие ее результата посредством 
	// 	return *this; // операций, не генерирующих исключений 
	// }

	// Использование скрытой реализации
	// почти строгая гарантия, так как мы не знаем как ведут себя T1, T2.

	// Потенциальные возражения и их необоснованность
	// - Некорректное утверждение №1. Полиморфизм в C++ не работает, поскольку мы не в состоянии сделать произвольный класс работающим вместо Base& без внесения в него изменений(для наследования его от Base).
	// - Некорректное утверждение №2. Контейнеры STL в C++ не работают, поскольку произвольный класс нельзя сделать содержимым контейнера без внесения изменений(обеспечивающего наличие оператора присваивания).
	// - Некорректное утверждение №3. Безопасность исключений в C++ не работает, поскольку мы не в состоянии обеспечить безопасность произвольного класса без внесения в него изменений(сокрытия внутреннего представления в классе реализации).
	// Вывод 1. Безопасность влияет на разработку класса
	// Вывод 2. Код всегда можно сделать (почти) строго безопасным
	// То, что класс не является безопасным, не является основанием для того, чтобы использующий его код не был безопасным(за исключением побочных действий).
	// - Локальная строгая гарантия. При генерации исключения состояние программы остается неизменным по отношению к контролируемым объектам.
	// Этот уровень безопасности всегда предполагает локальную семантику принятия - или - отката, включая корректность всех ссылок и итераторов в случае неуспешности операции.
	// Вывод 3. Благоразумно используйте указатели
	// 1. УКАЗАТЕЛИ — ВАШИ ВРАГИ, поскольку они приводят к проблемам, для решения которых и был разработан auto_ptг.
	// 2. УКАЗАТЕЛИ — ВАШИ ДРУЗЬЯ, поскольку операции с указателями не генерируют исключений.
	// - Используйте указатели, поскольку они ваши друзья, — ведь операции с указателями не могут генерировать исключения.
	// - Работайте с ними с использованием управляющих объектов, таких как auto_ptг, поскольку тем самым обеспечивается освобождение ресурсов.
	// Использование управляющих объектов не затрагивает отсутствия генерации исключений при работе с указателями, так как операции auto_ptг также не генерируют исключений(кроме того, вы всегда можете воспользоваться реальным указателем, получив его, например, вызовом auto_ptг:: get()).
	
	
	// Задача 2.19. Разработка безопасных классов. Часть 2(6)
	void task19();
	// Что означает "реализован посредством"?
	// Это может вас удивить, но выбор между наследованием и делегированием может привести к определенным последствиям с тонки зрения безопасности исключений.Можете ли вы определить, к каким?
	// 1. Что означает "реализован посредством"?
	// 2. В C++ отношение "реализован посредством" может быть выражено либо закрытым или защищенным наследованием, либо содержанием/делегированием, т.е.при написании класса т, реализованного посредством класса и, двумя основными вариантами являются закрытое наследование от и и включение и в качестве члена объекта.
	// Влияет ли выбор между этими методами на безопасность исключений? Поясните.

	// Реализация посредством: наследование или делегирование?
	// Меньшая степень взаимосвязи способствует корректности программы (включая безопасность исключений), в то время как тесная взаимосвязь снижает максимально возможную корректность программы.

	// Следствия безопасности исключений
	// 
	// пример 2а. T реализован посредством U
	// с использованием отношения содержит. 
	class U
	{

	};

	class T
	{
	public:
		T& T::operator=(const T& other)
		{
			U* temp = new U(*other.u_); // Вся работа выполняется отдельно, 
			delete u_; // а затем принимается с использованием 
			u_ = temp; // операций, не генерирующих исключения 
			return *this;
		}
		// ... 
	private:
		U* u_;
	};

	// Пример 26. T реализован посредством U
	// с использованием наследования
	class T1 : private U
	{
	public:
		T1& T1::operator=(const T1& other)
		{
			U::operator=(other); // ??? 
			return *this;
		}
		// ... 
	};
}
