#pragma once

// Управление памятью и ресурсами 
namespace nsMemoryAndResourceManagement
{
	void main();


	// Задача 6.1.Управление памятью.Часть 1(3)
	void task1();
	// Насколько хорошо вы знакомы с памятью? Какие различные области памяти существуют?
	// Константные данные
	// Стек
	// Свободная (динамическая) память
	// Куча 
	// Глобальная/статтичсская
	// Следует четко различать пять различных типов памяти: стек (автоматические переменные);
	// свободная память(new / delete); куча(mallос / free); глобальная область (статические, глобальные переменные, переменные области видимости файла и т.п.);
	// постоянные данные(строки и т.п.).
	// Предпочтительно использовать свободную память (new/delete); использования кучи (malloc/ free) следует избегать.
	
	
	// Задача 6.2. Управление памятью. Часть 2(6)
	void task2();
	// Пробовали ли вы использовать управление памятью в своих классах(или даже заменить глобальные new и delete собственными операторами)?
	// Перед тем как делать это, обдумайте хорошенько предложенную задачу.
	// 1. 
	class B
	{
	public:
		virtual ~B();
		void operator delete (void*, size_t ) throw();
		void operator delete[] ( void*, size_t ) throw();
		void f(void*, size_t ) throw();
	};

	class D : public B
	{
	public:
		void operator delete ( void* ) throw();
		void operator delete[] ( void* ) throw();
	};

	// В классе всегда должны быть либо определены как операторы new (new[]), так и операторы delete (delete[]), либо не определен ни один из них.
	// Всегда явно объявляйте operator new О и operator delete О как статические функции.
	// Нестатическими функциями - членами они быть не могут.
	
	// 2. Никогда не работайте с массивами полиморфно. 
	// Вместо массивов лучше использовать vector или deque. 

	// 3. Корректны ли два следующих присваивания?
	// Всегда явно объявляйте operator new() и operator delete() как статические функции.
	// Нестатическими функциями - членами они быть не могут.
	
	// 4. Имеются ли в следующем коде ошибки, связанные с управлением памятью? 
	class х
	{
	public:
		void* operator new(size_t s, int)
		{
			return ::operator new(s);
		}
	};

	// В классе всегда должны быть либо определены как операторы new (new[]), так и операторы delete (delete[]), либо не определен ни один из них.
	
	
	// Задача 6.3. Применение auto_ptr. Часть 1(8)
	void task3();
	// В этой задаче вы познакомитесь с тем, как эффективно и безопасно использовать стандартный шаблон auto_ptr.


	// Задача 6.4.Применение auto_ptr.Часть 2(5)
	void task4();
	// В этой задаче рассматриваются наиболее распространенные ловушки при использовании auto_ptr.
	// Сможете ли вы обнаружить проблему и разрешить ее?

	// Не забывайте о существовании шаблонов проектирования.
	// Предпочитайте применение vector использованию массивов в стиле С.


	// Задача 6.5. Интеллектуальные указатели-члены. Часть 1(5)
	void task5();
	// Большинство программистов на C++ знают, что при работе с указателями-членами следует принимать специальные меры.
	// А что делать с классами, членами которых являются auto_ptг?
	// Можно ли обезопасить себя и своих пользователей, разработав интеллектуальный указатель специального назначения для использования в качестве члена класса?
	
	
	// Задача 6.6. Интеллектуальные указатели-члены Часть 2(6)
	void task6();
	// Можно ли обезопасить себя и своих пользователей, разработав интеллектуальный указатель специального назначения для работы в качестве члена класса?
	// По умолчанию предпочтительно проектирование с учетом расширяемости.
}
