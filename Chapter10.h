#pragma once

namespace nsEverything
{
	void main();


	// Задача 10.1. Инициализация. Часть 1(3)
	void task1();
	// Эта задана демонстрирует важность понимания того, что вы пишете.
	// Здесь приведены четыре строки простейшего кода, которые, несмотря на малое различие в синтаксисе, означают разные вещи.
	// Т t;
	// T t();
	// T t(u);
	// T t = u;
	// Данная инициализация, несмотря на наличие в строке символа "=", всегда является именно инициализацией и никогда — присваиванием, так что при этом никогда не вызывается Т::operator=().
	// Это всего лишь пережиток синтаксиса С, а не операция присваивания.
	// Предпочтительно использовать инициализацию вида "Т t(u);", а не "Т t=u;". Первый метод работает везде, где работает второй, и имеет ряд преимуществ, в частности он допускает использование нескольких параметров.


	// Задача 10.2. Инициализация. Часть 2(3)
	void task2();
	// В чем состоит различие между непосредственной инициализацией и инициализацией копированием и когда они должны использоваться?
	// Предпочтительно использовать инициализацию вида "Т t(u);"f а не "Т t=u;".
	// class T : public S
	// {
	// public:
	// 	T() : S(1), // инициализация базового класса 
	// 		х(2) {} // инициализация члена 
	// 	X х;
	// };
	// При инициализации базового класса и члена используется непосредственная инициализация.
	// T f(T t) // Передача аргумента функции 
	// {
	// 	return t; // возврат значения 
	// }
	// При передаче и возврате значения используется инициализация копированием.
	// S s;
	// T t;
	// S& г = t;
	// reinterpret_cast<S&>(t); // выполнение reinterpret_cast 
	// dynamic_cast<T&>(r); // выполнение dynamic_cast 
	// const_cast<const T&>(t); // выполнение const_cast 
	// В этих случаях нет инициализации нового объекта — здесь происходит только создание ссылок.
	// static_cast<S>(t); // выполнение static_cast
	// При приведении static_cast используется непосредственная инициализация
	// try
	// {
	// 	throw T(); // генерация исключения
	// }
	// catch (T t) // Обработка исключения 
	// {
	// }
	// При генерации и перехвате объекта исключения используется инициализация копированием.
	// Вообще говоря, следует использовать перехват исключений по ссылке, а не по значению, чтобы избежать создания излишних копий и устранить потенциальную срезку объектов.
	// f(T(s)); // Преобразование типа
	// Это преобразование типов в стиле функции использует непосредственную инициализацию.
	// S а[3] = { 1, 2, 3 }; // инициализаторы в скобках
	// Инициализаторы в скобках используют инициализацию копированием.
	// S* р = new S(4); // Выражение new
	// И наконец, new использует непосредственную инициализацию.


	// Задача 10.3.Корректность const(6)
	void task3();
	// const представляет собой мощный инструмент для написания безопасного кода.  
	// Используйте const везде, где можно, но не более того.
	// В задаче показан ряд очевидных(и не совсем) мест, где следует(или не следует) использовать const.
	// Избегайте передани параметров по значению как const в объявлении функций. Если вы не хотите, чтобы эти параметры могли изменяться, используйте для них описание const в определении функции.
	// При возврате из функции объектов не встроенных типов по значению желательно возвращать константные объекты.
	// const и mutable — ваши друзья
	
	
	// Задача 10.4. Приведения(6)
	void task4();
	// Насколько хорошо вы знаете приведения типов в C++? Их использование может существенно повысить надежность вашего кода.
	// Предпочтительно использование приведений в новом стиле.
	// Избегайте приведения, отменяющего константность. Используйте вместо него ключевое слово mutable.
	// Избегайте приведения, отменяющего константность.
	// Избегайте понижающих приведений.
	
	
	// Задача 10.5- bool(7)
	void task5();
	// Так ли нужен нам тип bool? Почему бы просто не эмулировать его имеющимися в языке средствами?


	// Задача 10.6.Пересылающие функции(3)
	void task6();
	// Каким образом следует создавать пересылающие функции? Оказывается, даже здесь есть свои тонкости.
	// Внесение этих изменений было необходимо для устранения проблем, связанных с удалением вызовов конструкторов копирования, в особенности когда они обладали побочными действиями.
	// На сегодня единственной ситуацией, когда компилятор может устранить конструктор копирования, является оптимизация возвращаемого значения и оптимизация временных объектов.
	// Предпочтительно использовать передану объектов не по значению, а по ссылке, по возможности используя константные ссылки.
	// Избегайте "темных закутков" языка программирования. Среди методов, эффективно решающих поставленную задачу, выбирайте простейший.
	// Избегайте тонкой настройки производительности вообще и использования встроенности в частности до тех пор, пока необходимость этого не будет доказана с использованием профайлера.
	
	
	// Задача 10.7. Поток управления(6)
	void task7();
	// Насколько хорошо вы знаете порядок выполнения кода C++? Проверьте ваши знания, решив данную задачу.
	// Избегайте использования глобальных или статических объектов. Если вы вынуждены использовать такие объекты, не забывайте о порядке их инициализации.
	// В списке инициализации конструктора всегда располагайте базовые классы в том же порядке, в котором они перечислены в определении класса.
	// В списке инициализации конструктора всегда перечисляйте члены данных в том же порядке, в котором они перечислены в определении класса.
	// Всегда прилагайте максимум усилий для написания безопасного с тонки зрения исключений кода.Всегда структурируйте код так, чтобы при наличии исключений происходило корректное освобождение ресурсов, а данные находились в согласованном состоянии.
	// Никогда не пишите код, зависящий от порядка вычисления аргументов функции.
	// Вывод: никогда не пишите код с побочным действием внутри вызова assert() (или подобном ему), а кроме того, всегда убеждайтесь, что у вас нигде нет бесконечной рекурсии.
	// Никогда не пишите код, зависящий от порядка вычисления аргументов функции.
	
	
	// Задача 10.8. Предварительные объявления(3)
	void task8();
	// Предварительные объявления предоставляют возможность удалить излишние зависимости времени компиляции.
	// В этой задаче вы встретитесь с ловушками при применении предварительных объявлений.Сумеете ли вы обойти их?
	// Добавление объявлений или определений в namespace std или в пространства имен внутри namespace std приводит к неопределенным результатам.
	// Никогда не используйте директиву включения заголовочного файла #include там, где достаточно предварительного объявления.Кроме того, когда вы работаете с классами потоков, но вам не требуется их полное определение, предпочтительно использовать директиву #include <iosfwd>.
	
		
	// Задача 10.9. typedef(3)
	void task9();
	// Зачем мы используем typedef? Кроме традиционных причин, в этой задаче мы рассмотрим технологии использования typedef, которые делают стандартную библиотеку C++ более простой и безопасной.
	
	
	// Задача 10.10. Пространства имен. Часть 1(2)
	void task10();
	// Стандарт C++ включает поддержку пространств имен и управления видимостью имен с помощью объявлений и директив using.
	// Эта задача представляет собой небольшое повторение материала, подготавливая вас к встрече со следующей задачей.


	// Задача 10.11.Пространства имен.Часть 2(4)
	void task11();
	// Как наилучшим образом использовать возможности C++ по управлению пространствами имен и избежать при этом ошибок и ловушек?
	// Как наиболее эффективно перенести существующий код на C++ для работы с компилятором и библиотекой, поддерживающими пространства имен?
}
