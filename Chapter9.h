#pragma once

// Ловушки, ошибки и антиидиомы
namespace nsTrapsErrorsAntiidioms
{
	void main();


	// Задача 9.1.Тождественность объектов(5)
	void task1();
	// "Кто я?" В данной задаче выясняется вопрос о том, указывают ли два указателя на один и тот же объект.
	// Никогда не пишите оператор присваивания таким образом, чтобы для корректной работы он должен был полагаться на проверку присваивания самому себе.
	// Оператор присваивания, использующий идиому создания временного объекта и обмена, автоматически является строго безопасным в смысле исключений и в смысле присваивания самому себе.
	// Отсутствие проверки присваивания самому себе имеет две потенциальные причины снижения эффективности:
	// - Если вы можете проверить присваивание самому себе, то вы в состоянии оптимизировать код присваивания.
	// - Если вы можете проверить присваивание самому себе, то вы в состоянии оптимизировать код присваивания.
	// Можно использовать проверку на присваивание самому себе для оптимизации, заклю чающейся в устранении ненужной работы.
	// - Сравнение указателей в строковые литералы не определено.
	// - Вообще говоря, вы не можете сравнивать произвольные указатели с использованием встроенных операций <, <= , >, и >= , хотя в конкретных ситуациях результат таких операций определен.


	// Задача 9.2. Автоматические преобразования(4)
	void task2();
	// Автоматические преобразования от одного типа к другому могут быть исключительно удобны.
	// Эта задача показывает, почему автоматические преобразования могут оказаться исключительно опасными.
	// Почти всегда следует избегать автоматического преобразования типов, как путем предоставления оператора преобразования типа, так и посредством наличия не explicit конструктора с одним аргументом.
	// - Неявные преобразования могут мешать разрешению перегрузки.
	// - Неявные преобразования могут привести к компиляции неверного кода без каких - либо сообщений об ошибках.
	// Избегайте написания операторов преобразования типов и не-explicit конструкторов. 


	// Задача 9.3.Времена жизни объектов.Часть 1(5)
	void task3();
	// "Быть иль не быть... " Когда в действительности существует объект? В данной задаче выясняется, когда можно безопасно работать с объектами.
	// Всегда старайтесь писать безопасный в смысле исключений код.
	// Структурируйте код таким образом, чтобы даже при генерации исключений корректно освобождались все ресурсы, а данные находились в согласованном состоянии.
	// Избегайте "темных закутков" языка программирования. Среди методов, эффективно решающих поставленную задачу, выбирайте простейший.
	
	
	// Задача 9.4. Времена жизни объектов. Часть 2(6)
	void task4();
	// В данной задаче мы рассматриваем часто рекомендуемую идиому, которая нередко чревата ошибками.
	// В стандартах кодирования PeerDirect написано следующее:
	// - Объявляйте копирующее присваивание как T& Т::operator=(const T&)
	// - Не возвращайте const T&.
	// Избегайте "темных закутков" языка программирования. Среди методов, эффективно решающих поставленную задачу, выбирайте простейший.
	// Избегайте написания излишне сжатого кода, даже если при его написании вам совершенно ясно, как он работает.
	// Всегда старайтесь писать безопасный в смысле исключений код. Структурируйте код таким образом, чтобы даже при генерации исключений корректно освобождались все ресурсы, а данные находились в согласованном состоянии.
	// T& т::operator=(const T& other) 
	// {
	//	T temp(other);
	//	Swap(temp);
	//	return *this;
	// }
	// Предпочтительно обеспечить класс функцией - членом Swap(), не генерирующей исключений, и реализовать копирующее присваивание посредством конструктора копирования следующим образом.
}
